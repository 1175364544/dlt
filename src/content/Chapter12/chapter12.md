# Chapter12  神经情感分析
&emsp;&emsp;在本章中，我们将讨论自然语言处理中的热点和流行应用之一，即情感分析。如今，大多数人都通过社交媒体平台来表达自己对某件事的看法，而利用这一庞大的文本来追踪顾客对某件事的满意程度，对于公司甚至政府来说都是至关重要的。<br>
&emsp;&emsp;在本章中，我们将使用循环神经网络来建立一个情感分析的解决方案。本章将讨论以下主题：<br>
&emsp;&emsp;●一般情感分析体系结构<br>
&emsp;&emsp;●情感分析——模型实现<br>
## 一、一般情感分析体系结构
&emsp;&emsp;在本节中，我们将重点介绍可用于情感分析的一般深度学习体系结构。下图显示了构建情感分析模型所需的处理步骤。<br>
&emsp;&emsp;因此，首先，我们将讨论自然人类语言：<br>
![](https://github.com/yanjiusheng2018/dlt/blob/master/src/content/Chapter12/chapter12_image/picture1.png)<br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;图1：情感分析解决方案的一般传递途径，甚至是基于序列的自然语言解决方案<br>
&emsp;&emsp;我们将使用电影评论来构建这个情感分析应用程序。此应用程序的目标是根据输入的原始文本生成正面和负面的评论。例如，如果原始文本是这样的，“this movie is good”，那么我们需要模型来产生一个积极的情感。如果原始文本是“this is not a good movie”，那么我们就需要模型来产生一个消极的情感。情感分析应用程序将带领我们完成许多处理步骤，这些步骤是在神经网络(如嵌入)中使用自然人类语言所需要的。在这类应用中有几个困难：<br>
&emsp;&emsp;其中之一是序列可能有不同的长度。<br>
&emsp;&emsp;另一个问题是，如果我们只看单个单词(例如，good)，就会显示出一种积极的情感。然而，它的前面是“not”一词，那么它就是一种负面情感。这会使得我们的分析变得更加复杂，稍后我们会看到一个例子。<br>
&emsp;&emsp;正如我们在上一章中所了解的，神经网络不能工作在原始文本上，所以我们首先需要将它转换为所谓的数字。这些基本上都是整数值，我们需要遍历整个数据集，计算每个单词被使用的次数；然后，我们制作一个词汇表，每个单词都在这个词汇表中得到一个索引。如图1，单词this就转化为整数11，单词is转化为6，依此类推。
&emsp;&emsp;现在，我们已经将原始文本转换为一个名为token的整数列表。但神经网络仍然不能对这些数据进行操作，因为如果我们有10000个单词的词汇表，这些数字可以取0到9999之间的值，它们可能根本不相关。因此，与数字999相比，数字998可能有一个完全不同的语义。因此，我们将使用我们在上一章中学习到的表示学习或嵌入的思想。这个嵌入层将数字列表转换为实值向量，因此数字11转换为向量[0.67，0.36，…，0.39]，如图1所示。同样的情况也适用于下一个数字6。<br>
&emsp;&emsp;快速回顾我们在前一章中研究的内容：图1中所示的嵌入层会学习数字列表与它们对应的实值向量之间的映射。此外，嵌入层还会学习单词的语义，以便在这个嵌入空间中具有相似意义的单词之间有某种程度的接近。<br>
&emsp;&emsp;从输入的原始文本中，我们得到一个二维矩阵，即张量，它现在可以输入到循环神经网络(RNN)。它可以处理任意长度的序列，然后使该网络的输出具有Sigmoid激活函数的完全连接或dense层。因此，输出介于0到1之间，其中0值被认为是消极情感，1值被认为是积极情感。但是，如果Sigmoid函数的值既不是0也不是1呢？我们就需要在中间引入一个截断值或一个阈值，这样如果这个值低于0.5，那么相应的输入就被认为是一种消极情感，而高于这个阈值的值就会被认为是一种积极情感。<br>
### 1、RNNs——情感分析背景
&emsp;&emsp;让我们回顾一下RNNs的基本概念，并在情感分析应用中讨论它们。正如我们在RNN章中提到的，RNN的基本构造块是一个循环单元，如下图所示：<br>
![](https://github.com/yanjiusheng2018/dlt/blob/master/src/content/Chapter12/chapter12_image/picture2.png)<br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;图2：RNN单位的抽象概念<br>
&emsp;&emsp;这个图是循环单元内部所发生的事情的抽象。我们在这里得到的是输入，因此这将是一个词，例如，good；当然，它必须转换为嵌入向量。然而，我们现在将忽视这一点。此外，这个单元有一种记忆状态，根据该state（状态）的内容和input（输入），我们将更新此状态并将新数据写入状态。例如，假设我们以前在输入中看到了单词not；我们将它写入状态，这样当我们在后面的输入中看到good一词时，由于我们从状态中知道我们刚刚看到了not这个词，我们就必须把它们写在一起，看到not good一词的状态，这样才可能表明整个输入文本可能有一种消极情感。<br>
&emsp;&emsp;从旧的状态和输入到状态的新内容的映射是通过一个所谓的gate（闸门）来完成的，不同版本的循环单元实现这些映射的方式不同。它基本上是一个带有激活函数的矩阵运算，但是我们稍后会看到，反向传播梯度有一个问题。因此，RNN必须以一种特殊的方式来设计，这样梯度就不会被太大的扭曲。<br>
&emsp;&emsp;在一个循环单元中，我们有一个类似的gate（闸门）来产生输出，而循环单元的输出又一次依赖于状态的当前内容和我们所看到的输入。因此，我们可以尝试将一个循环单元内部发生的处理进行展开，如下图所示：<br>
![](https://github.com/yanjiusheng2018/dlt/blob/master/src/content/Chapter12/chapter12_image/picture3.png)<br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;图3：循环神经网络的展开图<br>
&emsp;&emsp;现在，我们这里只有一个循环单元，但是流程图显示了它在不同的时间步骤中发生了什么。因此：<br>
&emsp;&emsp;在时间步骤一中，我们将单词this输入到循环单元，它的内部记忆状态首先初始化为0。每当我们开始处理新的数据序列时，TensorFlow就会这样做。所以，我们看到单词this，循环单位状态是0。因此，我们使用内部gate（闸门）更新记忆状态，在时间步骤二中输入单词is，然后this在这个时间步骤二中使用，记忆状态就有了一些内容。然而This个词没有太多的意义，所以状态可能仍然是在0左右。而且is也没有太多的意义，所以也许这个状态仍然是0。<br>
&emsp;&emsp;在下一个时间步骤中，我们看到单词not，这是我们最终想要预测的整个输入文本的情感。它是我们需要存储在记忆中的东西以便循环单元内的gate（闸门）可以看到状态可能已经包含了接近于零的值。但是现在它想存储我们刚刚看到的单词not，所以它在这种状态下保存了一些非零值。<br>
&emsp;&emsp;然后，我们进入下一个时间步骤，在这里我们有一个单词a；这个词也没有太多的信息，所以它可能只是被忽略了。它只是复制到状态。<br>
&emsp;&emsp;现在，我们有了very一词，这表明，无论存在什么情绪，都可能是一种强烈的情绪，因此，现在知道我们已经看到的循环单位，not和very。它以某种方式将它存储在它的记忆状态中。<br>
&emsp;&emsp;在接下来的时间步骤里，我们看到了good这个词，所以现在网络知道not very good，它想，哦，这可能是一种消极情感！因此，它将该值存储在记忆状态中。<br>
&emsp;&emsp;然后，在最后的时间步骤里，我们看到movie，而这并不是真正相关的，所以它可能只是被忽略了。<br>
&emsp;&emsp;接下来，我们使用循环单元内的另一个gate（闸门）输出记忆状态的内容，然后用Sigmoid函数(这里不显示)处理它。我们得到0到1之间的输出值。<br>
&emsp;&emsp;我们的想法是，我们想通过网络电影数据库中成千上万的电影评论来训练这个网络，在这里，对于每一个输入文本，我们都给出了正反两方面的真实情感价值。然后，我们希望TensorFlow找出循环单元内部的gate（闸门）应该是什么，以便它们能够准确地将这个输入文本映射到正确的情感：<br>
![](https://github.com/yanjiusheng2018/dlt/blob/master/src/content/Chapter12/chapter12_image/picture4.png)<br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;图4：本章实现使用的架构<br>
&emsp;&emsp;我们将在这个实现中使用的RNN的体系结构是一个RNN类型的三层体系结构。在第一层，我们刚才解释的那部分已经发生了，只是现在我们需要在每个时间步骤输出循环单元的值。然后，我们收集了一个新的数据序列，即第一个循环层的输出。接下来，我们可以将它输入到第二层，因为循环单元需要输入数据的序列(我们从第一层得到的输出和我们想要输入到第二层的输出是一些浮点值，我们并不真正理解这些浮点值的含义)。这在RNN中有意义，但这不是我们人类所能理解的。然后，在第二层进行类似的处理。<br>
&emsp;&emsp;因此，首先，我们将这个循环单元的内部记忆状态初始化为0，然后，我们从第一个循环层获取第一个输出，并输入它。我们用这个循环单元内的gate（闸门）处理它，更新状态，将第一层的循环单元的输出作为第二个单词is，并使用它作为输入和内部记忆状态。我们继续这样做，直到我们处理完整个序列，然后我们收集第二个循环层的所有输出。我们使用它们作为第三个循环层的输入，在那里我们进行类似的处理。但是在这里，我们只需要最后一步的输出，这是对到目前为止所提供的所有内容的一种总结。然后，我们把它输出到一个完全连接的层，我们在这里不显示。最后，我们有Sigmoid激活函数，因此我们得到了一个介于0和1之间的值，它分别代表消极情感和积极情感。<br>
### 2、梯度爆炸和消失——回顾
&emsp;&emsp;我们在前一章中提到，有一种现象叫做梯度值的爆炸和消失，这在RNNs中是非常重要的。让我们回过头来看图1；这个流程图解释了这个现象是什么。<br> 
&emsp;&emsp;假设我们在这个数据集中有一个包含500个单词的文本，我们将使用它来实现我们的情感分析。在每一时间步骤中，我们以循环的方式在循环单元中应用内部gate（闸门）；因此，如果有500个单词，我们将应用这些gates（闸门）500次来更新循环单元的内部记忆状态。<br>
&emsp;&emsp;我们知道，神经网络的训练方式是使用梯度的反向传播，所以我们有一些损失函数，它得到神经网络的输出，然后得到我们对给定输入文本的真正输出。我们希望最小化这个损失值，以便神经网络的实际输出与这个特定输入文本的期望输出相对应。因此，我们需要取这个损失函数的梯度，相对于这些循环单元内的权重，这些权重用于更新内部状态并最终输出值的gates（闸门）。<br>
&emsp;&emsp;现在，gate（闸门）被应用了大约500次，如果其中有一个乘法，我们得到的实质是一个指数函数。所以，你用它自己乘以500倍，如果这个值略小于1，那么它就会很快消失或者失去。同样，如果一个略大于1的值与其自身相乘500倍，它就会爆炸。<br>
&emsp;&emsp;唯一能活过500次乘法的值是0和1。它们将保持不变，因此循环单位实际上比你在这里看到的要复杂得多。这是一个抽象的想法，我们想要以某种方式映射内部记忆状态和输入，以更新内部记忆状态并输出一些值——但实际上，我们需要非常小心地通过这些gates（闸门）向后传播梯度，这样我们就不会在许多时间步骤中出现指数乘法。我们也鼓励你们看一些关于循环单位的数学定义的教程。<br>
## 二、情感分析——模型实现
&emsp;&emsp;我们已经看到了如何实现RNNs的LSTM变体的所有细节和部分。为了让事情变得更令人兴奋，我们将使用一个名为Keras的更高级别的API。<br>
&emsp;&emsp;"Keras"是一个高级的神经网络API（应用程序编程接口），用Python编写，能够运行在TensorFlow、CNTK或Theano之上。它是以快速试验为重点开发的。能够在尽可能短的时间内从一个想法到另一个结果是做好研究的关键。”—Keras网站<br>
&emsp;&emsp;所以，Keras只是TensorFlow和其他深度学习框架的包装器。它非常适合于原型开发和快速构建，但另一方面，它使您对代码的控制更少。我们将借此机会在Keras中实现这个情感分析模型，这样您就可以在TensorFlow和Keras中得到一个手动实现。您可以使用keras进行快速原型开发，而tensorFlow用于生产准备系统。<br>
&emsp;&emsp;对你来说，更有趣的消息是，你不必切换到一个完全不同的环境。现在可以将Keras作为TensorFlow中的一个模块访问，并导入包，如下所示：<br>
&emsp;&emsp;from tensorflow.python.keras.models import sequential<br>
&emsp;&emsp;from tensorflow.python.keras.layers import dense GRU Embedding<br>
&emsp;&emsp;from tensorflow.python.keras.optimizers import Adam<br>
&emsp;&emsp;from tensorflow.python.keras.preprocession.sequence import pad_sequences<br>
&emsp;&emsp;因此，让我们继续使用我们现在所称的TensorFlow中一个更抽象的模块，它将帮助我们非常快地创建深度学习解决方案。这是因为我们将用几行代码编写完整的深度学习解决方案。<br>
### 1、数据分析和预处理
#### （1）导入所需模块
